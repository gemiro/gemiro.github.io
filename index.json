[
{
	"uri": "/kubernetes/installation/",
	"title": "쿠버네티스 설치하기",
	"tags": [],
	"description": "",
	"content": " 사전 준비  Centos7이 설치된 PC 2대 준비 각각 공유기에 Lan 선이 연결되고 인터넷이 가능한 상태  설치 과정 ifconfig 가 활성화 되어 있지 않다면 아래 명령어를 통해 net-tools 설치 yum install net-tools (yum update 이후)\n\r접근 편의를 위하여 ssh 서버를 설치한다. yum install openssh-server openssh-clients openssh-askpass (yum update 이후)\n\r두 PC의 NetworkManager와 firewalld를 정지시키고 Reboot 이후에도 자동 실행되지 않도록 disable 시킨다.\n# root user or sudo systemctl disable NetworkManager systemctl stop NetworkManager systemctl disable firewalld systemctl stop firewalld  Docker 설치 (모든 PC) Reference: Installing Docker CE\nDocker 설치를 위해서 Repository를 셋업 한다.\n# root user or sudo yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo  Docker CE 설치\n# root user or sudo yum yum install docker-ce docker-ce-cli containerd.io systemctl start docker usermod -aG docker \u0026lt;your-user\u0026gt; //\u0026lt;your-user\u0026gt;부분을 사용자 명으로 변경  마지막 usermod는 non-root user가 docker명령어를 사용하기 위한 명령어로 사용자를 docker group에 포함시킨다.\nkubeadm, kubelet, kubectl 설치 (모든 PC) Reference: Installing kubeadm, kubelet and kubectl\n# root user or sudo cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kube* EOF setenforce 0 sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes systemctl enable --now kubelet cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system  Kubernetes 마스터 구성 (마스터 PC) Reference: Creating a single master cluster with kubeadm\n아래 과정을 통해 마스터를 설정하고 Cluster를 구성하기 위한 token을 통해 slave들을 등록한다.\n# root user or sudo kubeadm init --pod-network-cidr=10.244.0.0/16 # [init] Using Kubernetes version: vX.Y.Z # [preflight] Running pre-flight checks # [preflight] Pulling images required for setting up a Kubernetes cluster # [preflight] This might take a minute or two, depending on the speed of your internet connection # [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' # [kubelet-start] Writin... # ... # Your Kubernetes master has initialized successfully! # # To start using your cluster, you need to run the following as a regular user: # # mkdir -p $HOME/.kube # sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config # sudo chown $(id -u):$(id -g) $HOME/.kube/config # # You should now deploy a pod network to the cluster. # Run \u0026quot;kubectl apply -f [podnetwork].yaml\u0026quot; with one of the options listed at: # /docs/concepts/cluster-administration/addons/ # # You can now join any number of machines by running the following on each node # as root: # # kubeadm join \u0026lt;master-ip\u0026gt;:\u0026lt;master-port\u0026gt; --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash sha256:\u0026lt;hash\u0026gt;  위 출력 내용 중 slave를 등록하기 전 non-root user가 kubectl을 접근하는 방법을 알려주고 있다. 해당 과정을 통해 regular user를 위한 kube config 파일을 HOME/.kube로 복사한다.\n# non-root user mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config kubectl get nodes # NAME STATUS ROLES AGE VERSION # master.k8s Ready master 1d v1.13.4  등록할 slave PC로 접속하여 위에서 발급 받은 token을 사용하여 master cluster에 join한다.\n# root urser or sudo kubeadm join \u0026lt;master-ip\u0026gt;:\u0026lt;master-port\u0026gt; --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash sha256:\u0026lt;hash\u0026gt;  join이 제대로 등록 되면 master node로 돌아가 아래 명령어를 쳐보자.\nkubectl get nodes # NAME STATUS ROLES AGE VERSION # master.k8s Ready master 1d v1.13.4 # slave1.k8s Ready \u0026lt;none\u0026gt; 1d v1.13.4  만약 Not Ready 문구가 나오면 좀 더 기다려 본다. 만약 지속적으로 Not Ready 상태이면 해당 master와 slave간 통신이 제대로 되는지 또는 /etc/hosts 파일에 각각 NAME 이름으로 host를 등록하고 다시 시도해보자.\n완료 이후 Pod 네트워크 add-on을 설치해야 다양한 네트워크 플러그인들이 존재한다. 여기서는 Flannel를 설치한다. 이유는 나중 metallb 와 호환성이 좋기 때문이다. metallb는 baremetal 상에 설치된 kubernetes에서 서비스의 LoadBalancer External IP를 제공하는 기능을 하는 플러그인이다.\n아래 명령어 한 줄이면 Flannel 구성이 완료된다.\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml  기본적으로 Master에는 pods 스케쥴링이 되지 않는다. 만약 Slave 노드 자원이 부족하여 Master 노드에도 pods 스케쥴링이 되도록 하고 싶으면 다음 명령어를 통해 마스터에도 스케쥴링 가능하도록 한다. $ kubectl taint nodes --all node-role.kubernetes.io/master- node \u0026ldquo;test-01\u0026rdquo; untainted taint \u0026ldquo;node-role.kubernetes.io/master:\u0026rdquo; not found taint \u0026ldquo;node-role.kubernetes.io/master:\u0026rdquo; not found\n\r"
},
{
	"uri": "/kubernetes/",
	"title": "KUBERNETES",
	"tags": [],
	"description": "",
	"content": " Kubernetes Contents  쿠버네티스 설치하기 Helm  "
},
{
	"uri": "/spring-boot/",
	"title": "SPRING BOOT",
	"tags": [],
	"description": "",
	"content": " Spring Boot Contents "
},
{
	"uri": "/kubernetes/helm/",
	"title": "Helm",
	"tags": [],
	"description": "",
	"content": " 소개 Kubernetes는 컨테이너 이미지를 배포하고 운영함에 있어 필요한 다양한 오케스트레이션 기능등을 지원하는 플랫폼이다. Kubernetes는 오케스트레이션 기능을 위해 YAML(또는 json) 파일을 사용하여 기능을 정의하고 관리한다. 하나의 컨테이너 이미지를 배포하기 위해서는 Kubernetes에서 제공하는 다양한 기능들을 이해하고 이를 YAML 파일을 사용하여 작성할 수 있어야하는데, 실제로 이미 잘 알려진 Mysql, MongoDB, Redis 등의 컨테이너 이미지를 docker hub 에서 내려받아 직접 YAML 파일을 작성하여 배포를 해 보면 이 일이 그렇게 말처럼 쉽지만은 않다는 것을 알 수 있다. 때문에 centos yum이나 ubuntu의 apt-get를 사용하면 쉽게 서비스를 설치하고 관리할 수 있는 것처럼 Kubernetes에서도 이와 비슷한 helm이라는 패키지 매니저가 나오게 되었다.\nhelm은 Kubernetes를 위한 패키지 매니저로써 helm 명령어를 통해 쉽게 어플리케이션을 배포하고 업데이트 삭제 등을 할 수 있다. helm은 어플리케이션을 배포하기 위해 chart repository를 사용하는데 이 repository에는 사용자 설정에 따라 kubernetes yaml을 동적으로 생성할 수 있는 chart 들이 저장되어 있다. chart는 직접 생성도 가능하지만 이미 Public으로 구축된 chart repository를 보면 대부분 필요한 어플리케이션등이 이미 마련되어 있다는 것을 알 수 있다.\n사전 준비  Kubernetes를 설치하고 master로 접속 kube config를 설정하여 kubectl 명령어를 사용할 수 있는 상태 Master node 에서 인터넷 접속이 가능한지 확인  설치 helm 사이트에서 다양한 설치 방법을 제공하고 있는데 가장 쉽게 설치할 수 있는 방법은 스크립트를 다운받아 설치하는 것을 추천한다.\n아래 과정을 통해 스크립트를 다운받고 실행한다. 그러면 helm을 설치할 수 있는 환경이 구성된다.\ncurl https://raw.githubusercontent.com/helm/helm/master/scripts/get \u0026gt; get_helm.sh chmod 700 get_helm.sh ./get_helm.sh  환경이 구성되었으면 다음은 tiller를 설치해야 한다. tiller는 helm 서버의 일부분으로 kubernetes cluster에 pod로 올라간다. tiller는 기본적으로 kube-system namespace에 배포되고 tiller를 통해 배포되는 어플리케이션들은 실제로 다른 namespace에 배포되기 때문에 tiller에 적절한 cluster role이 설정되어야 한다. 아래 shell 명령어는 cluster-admin cluster role을 생성하고 이를 tiller에 binding 한 후 helm init을 통해 tiller를 배포하게 된다.\nkubectl create serviceaccount --namespace kube-system tiller kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller helm init kubectl patch deploy --namespace kube-system tiller-deploy -p '{\u0026quot;spec\u0026quot;:{\u0026quot;template\u0026quot;:{\u0026quot;spec\u0026quot;:{\u0026quot;serviceAccount\u0026quot;:\u0026quot;tiller\u0026quot;}}}}'  배포가 완료 되었으면 아래 명령어를 통해 helm이 잘 동작하는지 확인한다.\n# helm repository 확인 : 기본적으로 stable repository만 검색이 된다. helm search # NAME CHART VERSION APP VERSION DESCRIPTION # incubator/artifactory 5.2.1 5.2.0 DEPRECATED Universal Repository Manager supporting all ma... # incubator/aws-alb-ingress-controller 0.1.4 v1.0.1 A Helm chart for AWS ALB Ingress Controller # incubator/azuremonitor-containers 0.5.0 2.0.0-3 Helm chart for deploying Azure Monitor container monitori... # incubator/burrow 0.3.3 0.17.1 Burrow is a permissionable smart contract machine # incubator/cassandra 0.10.4 3.11.3 Apache Cassandra is a free and open-source distributed da... # ... helm install --name my-release stable/mysql # NAME: my-release # LAST DEPLOYED: Sun Apr 7 16:51:10 2019 # NAMESPACE: default # STATUS: DEPLOYED # # RESOURCES: # ==\u0026gt; v1/ConfigMap # NAME DATA AGE # my-release-mysql-test 1 1s # # ==\u0026gt; v1/PersistentVolumeClaim # NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE # my-release-mysql Pending 1s # # ==\u0026gt; v1/Pod(related) # NAME READY STATUS RESTARTS AGE # my-release-mysql-796c4bdb6c-z7mqc 0/1 Pending 0 1s # # ==\u0026gt; v1/Secret # NAME TYPE DATA AGE # my-release-mysql Opaque 2 1s # # ==\u0026gt; v1/Service # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # my-release-mysql ClusterIP 10.107.170.208 \u0026lt;none\u0026gt; 3306/TCP 1s # # ==\u0026gt; v1beta1/Deployment # NAME READY UP-TO-DATE AVAILABLE AGE # my-release-mysql 0/1 1 0 1s # # # NOTES: # MySQL can be accessed via port 3306 on the following DNS name from within your cluster: # my-release-mysql.default.svc.cluster.local # # To get your root password run: # # MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default my-release-mysql -o jsonpath=\u0026quot;{.data.mysql-root-password}\u0026quot; | base64 --decode; echo) # # To connect to your database: # # 1. Run an Ubuntu pod that you can use as a client: # # kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il # # 2. Install the mysql client: # # $ apt-get update \u0026amp;\u0026amp; apt-get install mysql-client -y # # 3. Connect using the mysql cli, then provide your password: # $ mysql -h my-release-mysql -p # # To connect to your database directly from outside the K8s cluster: # MYSQL_HOST=127.0.0.1 # MYSQL_PORT=3306 # # # Execute the following command to route the connection: # kubectl port-forward svc/my-release-mysql 3306 # # mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD} # 위와 같은 결과가 출력되면 helm이 잘 작동한다는 것이다. # 아래 명령어는 배포된 mysql를 삭제하는 명령어이며 --purge 옵션은 배포된 my-release에 대한 name 히스토리를 삭제한다는 옵션이다. # 만약 --purge 옵션을 주지 않고 삭제한 경우 다음 배포할 때 my-release 이름으로 배포하면 에러가 난다. helm delete my-release --purge  "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\n.ghContributors{\rdisplay:flex;\rflex-flow: wrap;\ralign-content: flex-start\r}\r.ghContributors  div{\rwidth: 50% ;\rdisplay: inline-flex;\rmargin-bottom: 5px;\r}\r.ghContributors  div label{\rpadding-left: 4px ;\r}\r.ghContributors  div span{\rfont-size: x-small;\rpadding-left: 4px ;\r}\r\r\r@matcornic\r149 commits\r\r\r@matalo33\r35 commits\r\r\r@lierdakil\r16 commits\r\r\r@gwleclerc\r13 commits\r\r\r@mdavids\r10 commits\r\r\r@coliff\r9 commits\r\r\r@ozobi\r5 commits\r\r\r@Xipas\r5 commits\r\r\r@pdelaby\r4 commits\r\r\r@mreithub\r3 commits\r\r\r@massimeddu\r3 commits\r\r\r@willwade\r3 commits\r\r\r@denisvm\r2 commits\r\r\r@gpospelov\r2 commits\r\r\r@tanzaho\r2 commits\r\r\r@wikijm\r2 commits\r\r\r@lfalin\r2 commits\r\r\r@alexvargasbenamburg\r1 commits\r\r\r@afs2015\r1 commits\r\r\r@arifpedia\r1 commits\r\r\r@MrMoio\r1 commits\r\r\r@ChrisLasar\r1 commits\r\r\r@IEvangelist\r1 commits\r\r\r@giuliov\r1 commits\r\r\r@haitch\r1 commits\r\r\r@ImgBotApp\r1 commits\r\r\r@RealOrangeOne\r1 commits\r\r\r@JohnBlood\r1 commits\r\r\r@kamilchm\r1 commits\r\r\r@lloydbenson\r1 commits\r\r\r@sykesm\r1 commits\r\r\r@654wak654\r1 commits\r\r\r@PierreAdam\r1 commits\r\r\r@ripienaar\r1 commits\r\r\r@EnigmaCurry\r1 commits\r\r\r@taiidani\r1 commits\r\r\r@exKAZUu\r1 commits\r\r\r@shelane\r1 commits\r\r\r@tedyoung\r1 commits\r\r\r@Thiht\r1 commits\r\r\r@editicalu\r1 commits\r\r\r@fossabot\r1 commits\r\r\r@kamar535\r1 commits\r\r\r@nonumeros\r1 commits\r\r\r@pgorod\r1 commits\r\r\r@proelbtn\r1 commits\r\r And a special thanks to @vjeantet for his work on docdock, a fork of hugo-theme-learn. v2.0.0 of this theme is inspired by his work.\nPackages and libraries  mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; horsey - Progressive and customizable autocomplete component clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support  Tooling  Netlify - Continuous deployement and hosting of this documentation Hugo  "
},
{
	"uri": "/",
	"title": "Learn Theme for Hugo",
	"tags": [],
	"description": "",
	"content": " Hugo learn theme Hugo-theme-learn is a theme for Hugo, a fast and modern static website engine written in Go. Where Hugo is often used for blogs, this multilingual-ready theme is fully designed for documentation.\nThis theme is a partial porting of the Learn theme of Grav, a modern flat-file CMS written in PHP.\nLearn theme works with a page tree structure to organize content : All contents are pages, which belong to other pages.\n\rMain features  Unlimited menu levels Automatic next/prev buttons to navigate through menu entries  Contribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it\nYour modification will be deployed automatically when merged.\n\rDocumentation website This current documentation has been statically generated with Hugo with a simple command : hugo -t hugo-theme-learn \u0026ndash; source code is available here at GitHub\nAutomatically published and hosted thanks to Netlify. Read more about Automated HUGO deployments with Netlify\n\r"
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]